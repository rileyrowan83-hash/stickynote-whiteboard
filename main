<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Quiet Ledger — Whiteboard</title>
<style>
  :root{
    --bg:#eef2f6;
    --board:#fffef9;
    --muted:#6b6e73;
    --ink:#0b0b0c;
    --post:#fff99a;
    --shadow: 0 18px 40px rgba(10,10,12,0.08);
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; -webkit-font-smoothing:antialiased;}
  body{background:linear-gradient(180deg,#f3f6f9,#eef2f6); padding:18px; display:flex; justify-content:center; color:var(--ink);}

  .container{width:100%;max-width:1100px; display:grid; grid-template-columns:1fr 360px; gap:20px; align-items:start;}
  .board{
    background:var(--board); border-radius:12px; padding:20px; min-height:76vh;
    box-shadow:var(--shadow); border:1px solid rgba(0,0,0,0.04); position:relative; overflow:hidden;
  }
  .board h1{margin:0;font-size:26px;}
  .board p{color:var(--muted); margin-top:6px;margin-bottom:14px;}

  .controls{display:flex; gap:8px; margin-bottom:12px;}
  .btn{padding:8px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:700;}
  .btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06);}
  .btn.primary{background:#111827;color:#fff}

  /* notes container (absolute-positioned notes) */
  .notes-area{position:relative; width:100%; height:62vh; border-radius:10px; background:linear-gradient(180deg,#fbfbfb,#fffef8); border:1px dashed rgba(0,0,0,0.03); overflow:auto; padding:8px;}

  .note {
    position:absolute;
    width:160px;
    min-height:110px;
    padding:10px;
    border-radius:10px;
    background: linear-gradient(180deg,#fff,#fff8d6);
    box-shadow:0 10px 28px rgba(0,0,0,0.08);
    border:1px solid rgba(0,0,0,0.04);
    transform-origin:center;
    touch-action:none;
  }
  .note .note-content{outline:none; white-space:pre-wrap; word-break:break-word; font-size:14px; line-height:1.2;}
  .note .note-meta{display:flex; justify-content:space-between; align-items:center; margin-top:8px; font-size:12px;}
  .note .note-meta button{background:transparent;border:none;color:var(--muted);cursor:pointer;font-weight:600}

  /* realistic sticky corners */
  .note::before{
    content:"";
    position:absolute; left:12px; top:-8px; width:56px; height:12px;
    background:linear-gradient(90deg, rgba(255,255,255,0.6), rgba(255,255,255,0.2));
    border-radius:4px; transform:rotate(-4deg);
  }

  /* side column (sticky input) */
  .side{min-height:76vh; position:relative;}
  .sticky-control{position:sticky; top:22px; background:linear-gradient(180deg,#fff7b6,#fff59d); padding:12px; border-radius:12px; box-shadow:var(--shadow); border:1px solid rgba(0,0,0,0.06); transform:rotate(-2deg);}
  .sticky-control h4{margin:0 0 8px;}
  textarea#inputNote{width:100%; min-height:96px; resize:vertical; padding:10px; border-radius:8px; border:1px dashed rgba(0,0,0,0.06); font-family:inherit;}

  /* tiny decorative login at top-right (inert unless enabled) */
  .tiny-login{position:fixed; right:12px; top:8px; font-size:12px; padding:6px 8px; border-radius:6px; background:transparent; border:1px solid rgba(0,0,0,0.06); color:var(--muted); cursor:default; z-index:60; opacity:0.95;}
  .tiny-login.enabled{background:#111827; color:#fff; cursor:pointer;}

  /* overlay */
  .overlay{position:fixed; inset:0; display:none; place-items:center; background:linear-gradient(180deg, rgba(8,8,9,0.6), rgba(8,8,9,0.86)); z-index:90; backdrop-filter: blur(4px); color:#dbeefc;}
  .panel{width:min(920px,94%); max-height:86vh; overflow:auto; background:linear-gradient(180deg,#07080a,#050405); border-radius:10px; padding:18px; font-family:monospace; font-size:13px;}
  .closeX{position:absolute; right:12px; top:8px; background:transparent; border:none; color:#dbe; font-size:18px; cursor:pointer;}

  footer.small{color:var(--muted); margin-top:12px; font-size:13px;}

  @media (max-width:920px){
    .container{grid-template-columns:1fr; padding-bottom:120px;}
    .tiny-login{right:8px; top:6px;}
  }

  /* Hidden puzzle fragments in comments for players:
     fragA_hex: 4d61676963  (-> "Magic")
     fragB_b64: c3VibGltZQ== (-> "sublime")
     fragC_unicode: 𝔏𝔦𝔤  (visual noise)
     connector: " || "
  */
</style>
</head>
<body>
  <button id="tinyLogin" class="tiny-login" title="Login (disabled)">Login</button>

  <div class="container" role="main">
    <main class="board" aria-label="whiteboard">
      <h1>Quiet Ledger</h1>
      <p>A realistic whiteboard with plastic sticky notes — create quick reminders, quotes, lists, or daily tasks. Drag, edit, and they’ll stay on your device.</p>

      <div class="controls">
        <button id="addBtn" class="btn ghost">+ New Note</button>
        <button id="exportBtn" class="btn">Export notes</button>
        <button id="importBtn" class="btn ghost">Import</button>
        <button id="clearBtn" class="btn" style="background:#f3f4f6;color:#111;border:1px solid rgba(0,0,0,0.04);">Clear all</button>
      </div>

      <div id="notesArea" class="notes-area" tabindex="0" aria-label="notes area">
        <!-- notes are added here (absolute-position) -->
      </div>

      <footer class="small">Notes are stored on this device. Use the sticky input on the right to add quick text or to test the hidden passphrase.</footer>
    </main>

    <aside class="side" aria-label="controls">
      <div class="sticky-control" role="region" aria-label="sticky note input">
        <h4>Sticky Note</h4>
        <textarea id="inputNote" placeholder="Write a quick note — or type a deliberate passphrase here..."></textarea>
        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
          <button id="peekBtn" class="btn ghost">Peek</button>
          <button id="submitBtn" class="btn primary">Reveal</button>
        </div>
        <div style="font-size:12px;color:var(--muted); margin-top:8px;">Notes can store quotes, lists, or reminders. Exact phrase required to enable Login.</div>
      </div>

      <div style="height:14px;"></div>

      <div style="background:linear-gradient(180deg,#fff,#fcfcfb); border-radius:10px; padding:12px; border:1px solid rgba(0,0,0,0.04); box-shadow:0 10px 24px rgba(0,0,0,0.04);">
        <strong style="display:block;margin-bottom:6px;">Starter ideas</strong>
        <ul style="margin:0; padding-left:18px; color:var(--muted); font-size:13px;">
          <li>“Breathe. One step at a time.”</li>
          <li>Grocery: milk • eggs • bread</li>
          <li>Call Mom — Friday</li>
          <li>Daily goal: 30 min practice</li>
        </ul>
      </div>
    </aside>
  </div>

  <!-- overlay for reveal and faux logs -->
  <div id="overlay" class="overlay" role="dialog" aria-hidden="true">
    <div class="panel" role="document">
      <button id="closeOverlay" class="closeX" title="Close">✕</button>
      <pre id="output" style="white-space:pre-wrap; margin:0; color:#cfe8ff; font-family:monospace;"></pre>
    </div>
  </div>

<script>
/* ============================
   Sticky notes system with drag (touch + mouse)
   Persistent storage via localStorage
   ============================ */

const LS_KEY = 'ql_notes_v2';

// generate id
function genId(){ return 'n_' + Math.random().toString(36).slice(2,10); }

// load/save
function loadNotes(){ try{ const r = localStorage.getItem(LS_KEY); return r ? JSON.parse(r) : []; }catch(e){ return []; } }
function saveNotes(notes){ localStorage.setItem(LS_KEY, JSON.stringify(notes)); }

// DOM refs
const notesArea = document.getElementById('notesArea');
const addBtn = document.getElementById('addBtn');
const clearBtn = document.getElementById('clearBtn');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const inputNote = document.getElementById('inputNote');
const submitBtn = document.getElementById('submitBtn');
const peekBtn = document.getElementById('peekBtn');
const tinyLogin = document.getElementById('tinyLogin');
const overlay = document.getElementById('overlay');
const output = document.getElementById('output');
const closeOverlay = document.getElementById('closeOverlay');

let dragging = null;
let offset = {x:0,y:0};

// create note element
function createNoteElement(note){
  const el = document.createElement('div');
  el.className = 'note';
  el.style.left = (note.x || 20) + 'px';
  el.style.top = (note.y || 20) + 'px';
  el.style.transform = `rotate(${note.rot || (Math.random()*6-3)}deg)`;

  el.dataset.id = note.id;

  const content = document.createElement('div');
  content.className = 'note-content';
  content.contentEditable = true;
  content.spellcheck = false;
  content.innerText = note.text || '';
  content.addEventListener('blur', ()=> {
    updateNote(note.id, content.innerText);
  });
  content.addEventListener('keydown', (e)=> {
    if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); content.blur(); }
  });

  const meta = document.createElement('div');
  meta.className = 'note-meta';
  const del = document.createElement('button');
  del.innerText = 'Delete';
  del.addEventListener('click', ()=> { deleteNote(note.id); });
  meta.appendChild(del);

  el.appendChild(content);
  el.appendChild(meta);

  // drag handlers (mouse)
  el.addEventListener('mousedown', (ev)=> {
    dragging = el;
    const rect = el.getBoundingClientRect();
    offset.x = ev.clientX - rect.left;
    offset.y = ev.clientY - rect.top;
    document.body.style.userSelect = 'none';
  });
  // touch
  el.addEventListener('touchstart', (ev)=> {
    dragging = el;
    const rect = el.getBoundingClientRect();
    const t = ev.touches[0];
    offset.x = t.clientX - rect.left;
    offset.y = t.clientY - rect.top;
  }, {passive:true});

  return el;
}

function renderNotes(){
  notesArea.innerHTML = '';
  const notes = loadNotes();
  for(const n of notes){
    const el = createNoteElement(n);
    notesArea.appendChild(el);
  }
}

// global move handlers
document.addEventListener('mousemove', (ev)=>{
  if(!dragging) return;
  const x = ev.clientX - offset.x - notesArea.getBoundingClientRect().left + notesArea.scrollLeft;
  const y = ev.clientY - offset.y - notesArea.getBoundingClientRect().top + notesArea.scrollTop;
  dragging.style.left = Math.max(6, x) + 'px';
  dragging.style.top = Math.max(6, y) + 'px';
});
document.addEventListener('mouseup', ()=>{
  if(dragging){
    persistPosition(dragging);
    dragging = null;
    document.body.style.userSelect = '';
  }
});
// touch move
document.addEventListener('touchmove', (ev)=> {
  if(!dragging) return;
  const t = ev.touches[0];
  const x = t.clientX - offset.x - notesArea.getBoundingClientRect().left + notesArea.scrollLeft;
  const y = t.clientY - offset.y - notesArea.getBoundingClientRect().top + notesArea.scrollTop;
  dragging.style.left = Math.max(6, x) + 'px';
  dragging.style.top = Math.max(6, y) + 'px';
}, {passive:true});
document.addEventListener('touchend', ()=> {
  if(dragging){
    persistPosition(dragging);
    dragging = null;
  }
});

function persistPosition(el){
  const id = el.dataset.id;
  const notes = loadNotes();
  const idx = notes.findIndex(x=>x.id===id);
  if(idx>=0){
    notes[idx].x = parseInt(el.style.left,10) || 0;
    notes[idx].y = parseInt(el.style.top,10) || 0;
    saveNotes(notes);
  }
}

function addNoteWithText(text=''){
  const notes = loadNotes();
  const n = { id: genId(), text: text, x: 30 + (notes.length%4)*24, y: 30 + (Math.floor(notes.length/4)%4)*18, rot: (Math.random()*6-3).toFixed(2) };
  notes.unshift(n);
  saveNotes(notes);
  renderNotes();
}
function updateNote(id, text){
  const notes = loadNotes();
  const idx = notes.findIndex(x=>x.id===id);
  if(idx>=0){ notes[idx].text = text; saveNotes(notes); }
}
function deleteNote(id){
  let notes = loadNotes();
  notes = notes.filter(x=>x.id !== id);
  saveNotes(notes);
  renderNotes();
}
function clearAll(){
  if(confirm('Clear all notes? This cannot be undone.')){ localStorage.removeItem(LS_KEY); renderNotes(); }
}
function exportNotes(){
  const data = JSON.stringify(loadNotes(), null, 2);
  const w = window.open();
  w.document.open();
  w.document.write('<pre>'+escapeHtml(data)+'</pre>');
  w.document.close();
}
function importNotes(){
  const txt = prompt('Paste exported notes JSON here:');
  try{
    const parsed = JSON.parse(txt);
    if(Array.isArray(parsed)){ localStorage.setItem(LS_KEY, JSON.stringify(parsed)); renderNotes(); } else alert('Invalid format.');
  }catch(e){ alert('Invalid JSON.'); }
}
function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

addBtn.addEventListener('click', ()=> addNoteWithText(''));
clearBtn.addEventListener('click', clearAll);
exportBtn.addEventListener('click', exportNotes);
importBtn.addEventListener('click', importNotes);

// initialize
if(loadNotes().length === 0){
  addNoteWithText("Breathe. One step at a time.");
  addNoteWithText("Grocery: milk • eggs • bread");
}
renderNotes();

/* ================================
   Secret obfuscation & unlock flow
   Client-side obfuscation (medium difficulty):
   - obfHex is XOR(sha256(secretPhrase), sha256(materialFromFragments))
   - fragments are scattered here in different encodings; attacker must assemble them to compute target.
   - This makes the phrase not plainly visible in source.
   NOTE: This is puzzle-oriented client-side obfuscation (not as secure as server-side).
   ================================ */

/* Fragments (puzzle pieces):
   fragA_hex = "4d61676963" -> "Magic"
   fragB_b64 = "c3VibGltZQ==" -> "sublime"
   fragC_unicode = "𝔏𝔦𝔤"
   fragD = " || "
*/
const fragA_hex = "4d61676963";
const fragB_b64 = "c3VibGltZQ==";
const fragC_unicode = "𝔏𝔦𝔤";
const fragD = " || ";

/* obfuscated hex (XOR of target hash and derived key hash) */
const obfHex = "d33e63f98b89c101af05c204243cfdcf43c3c61179a6a74491abfb93d5f1aa73";

/* utilities */
function hexToBytes(hex){
  const b = new Uint8Array(hex.length/2);
  for(let i=0;i<b.length;i++) b[i] = parseInt(hex.substr(i*2,2),16);
  return b;
}
function bytesToHex(arr){ return Array.from(arr).map(x=>x.toString(16).padStart(2,'0')).join(''); }
function strToBytes(s){ return new TextEncoder().encode(s); }
function xorBytes(a,b){
  const n = Math.min(a.length,b.length);
  const out = new Uint8Array(n);
  for(let i=0;i<n;i++) out[i] = a[i] ^ b[i];
  return out;
}
async function sha256hex(msg){
  const data = strToBytes(msg);
  const h = await crypto.subtle.digest('SHA-256', data);
  return bytesToHex(new Uint8Array(h));
}

/* decode fragments -> material -> derive key */
function decodeFragA(){
  let s = "";
  for(let i=0;i<fragA_hex.length;i+=2) s += String.fromCharCode(parseInt(fragA_hex.substr(i,2),16));
  return s;
}
function decodeFragB(){
  try{ return atob(fragB_b64); }catch(e){ return ""; }
}
function buildMaterial(){
  return decodeFragA() + decodeFragB() + fragC_unicode + fragD;
}
async function deriveKeyHex(){
  const m = buildMaterial();
  return await sha256hex(m);
}
async function recoverTargetHashHex(){
  const keyHex = await deriveKeyHex();
  const ob = hexToBytes(obfHex);
  const keyBytes = hexToBytes(keyHex);
  const x = xorBytes(ob, keyBytes);
  return bytesToHex(x); // hex of sha256(secretPhrase)
}

/* normalize text policy -- collapse spaces, trim */
function normalizeText(s){ return s.replace(/\s+/g, ' ').trim(); }

/* reveal UI */
function showOverlay(text){
  output.textContent = text;
  overlay.style.display = 'grid';
  overlay.setAttribute('aria-hidden','false');
}
closeOverlay.addEventListener('click', ()=> { overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); });

async function progressiveReveal(){
  output.textContent = '';
  overlay.style.display = 'grid';
  overlay.setAttribute('aria-hidden','false');
  const lines = [
    "4d 65 74 61  |  74 68 65 20 72 6f 6f 6d 73 20 6b 65 65 70 2e",
    "VGhlIG1vcm5pbmctbGlnaHQgaGFzIG5vdCBsZWZ0Lg==",
    "01101001 01110100 00100000 01100011 01101100 01101001 01101110 01100111",
    "<< log 1087: observation archived >>",
    "key: [fragments assembled]"
  ];
  function append(t){ output.textContent += t + "\n"; output.scrollTop = output.scrollHeight; }
  for(const ln of lines){
    append("> " + ln);
    await new Promise(r => setTimeout(r,680));
    const trimmed = ln.trim();
    if(trimmed.includes("4d 65")){
      try{
        const parts = trimmed.split(/\s+/).map(h => parseInt(h,16)).filter(n => !Number.isNaN(n));
        append("  → hex: " + String.fromCharCode(...parts));
      }catch(e){}
    } else if(trimmed.match(/^[A-Za-z0-9+/=]+$/) && trimmed.endsWith("==")){
      try{ append("  → base64: " + atob(trimmed)); }catch(e){}
    } else if(trimmed.match(/^[01\s]+$/)){
      try{
        const bytes = trimmed.split(/\s+/).map(b => String.fromCharCode(parseInt(b,2))).join('');
        append("  → bin: " + bytes);
      }catch(e){}
    }
  }
  await new Promise(r=>setTimeout(r,900));
  append("\n////// RECOVERY ATTAINED //////\n");
  append("it listened. it learned by shadow.");
  append("some things were catalogued. some things were folded away.");
  append("\n— the ledger\n");
}

/* main submit handler: check all notes (and input) for secret phrase */
let unlocked = false;
submitBtn.addEventListener('click', async ()=>{
  const rawInput = (inputNote.value || "").toString();
  const normInput = normalizeText(rawInput);
  if(!normInput){ alert('Write something first.'); return; }

  try{
    const targetHash = await recoverTargetHashHex();
    const inputHash = await sha256hex(normInput);

    if(inputHash === targetHash){
      unlocked = true;
      tinyLogin.classList.add('enabled');
      tinyLogin.title = "Login (enabled)";
      progressiveReveal();
      // The input note text does not get changed; we enable login
    } else {
      // Also check existing notes: user might type inside a note and not the sticky input
      const notes = loadNotes();
      let matched = false;
      for(const n of notes){
        const norm = normalizeText(n.text || '');
        if(norm){
          const h = await sha256hex(norm);
          if(h === targetHash){ matched = true; break; }
        }
      }
      if(matched){
        unlocked = true;
        tinyLogin.classList.add('enabled');
        tinyLogin.title = "Login (enabled)";
        progressiveReveal();
      } else {
        const echo = rawInput.length > 140 ? rawInput.slice(0,140) + '…' : rawInput;
        showOverlay('> access token invalid\n> handshake failed\n> echo: "' + echo + '"\n\n<no further output>');
      }
    }
  } catch(e){
    showOverlay('error: ' + (e && e.message ? e.message : 'unknown'));
  }
});

/* tiny login only works if unlocked; otherwise inert */
tinyLogin.addEventListener('click', ()=>{
  if(!unlocked) return; // completely inert otherwise
  // go to blank page
  window.location.href = 'about:blank';
});

/* close overlay on Escape */
document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape'){ overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); } });

</script>
</body>
</html>
